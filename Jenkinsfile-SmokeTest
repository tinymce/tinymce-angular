#!groovy
@Library('waluigi@release/7') _

properties([
  disableConcurrentBuilds(),
  buildDiscarder(logRotator(
    artifactDaysToKeepStr: '',
    artifactNumToKeepStr: '1',
    daysToKeepStr: '',
    numToKeepStr: '50'
  )),
  parameters([
    string(defaultValue: 'next', description: 'The NPM publish tag ', name: 'NPM_TAG', trim: false),
  ])
])

// Generates a custom route file that contains the next version of Angular to test against
def generateNPMVersionRouteFile(Map args = new LinkedHashMap()) {
  writeJSON file: "${args.filePath}", json: args.content
}

// Updates the Angular dependencies to the version specified by the npm tag
def updateDependenciesWithTag(Map args = new LinkedHashMap()) {
  sh "yarn add @angular/core@${args.npmTag} @angular/animations@${args.npmTag} @angular/common@${args.npmTag} @angular/compiler@${args.npmTag} @angular/core@${args.npmTag} @angular/forms@${args.npmTag} @angular/platform-browser@${args.npmTag} @angular-devkit/build-angular@${args.npmTag} @angular/cli@${args.npmTag} @angular/compiler-cli@${args.npmTag}"
}

def runSmokeTests(Map args = new LinkedHashMap()) {
  def platforms = args.platforms ?: [
    [ browser: "chrome", provider: "lambdatest" ]
  ]
  String additionalArgs = "--chunk 20 --totalTimeout 1800000 --singleTimeout 90000 --retries 3 --customRoutes ${args.routeFilePath}"

  def processes = [:]

  for (int i = 0; i < platforms.size(); i++) {
    def platform = platforms.get(i)
    def buckets = platform.buckets ?: 1

    for (int bucket = 1; bucket <= buckets; bucket++) {
      // clousure var - don't inline or jenkins complains
      def currBucket = bucket
      def suffix = currBucket == 1 ? '' : "-${currBucket}"

      // Run using remote provider
      if (platform.provider) {
        def name = "${platform.browser}-${platform.provider}${suffix}"
        processes[name] = {
          stage("${name}") {
            bedrockRemoteTools.tinyWorkSishTunnel()
            bedrockRemoteTools.withRemoteCreds(platform.provider) {
              String customArgs = additionalArgs + " --remote ${platform.provider}"
              if (platform.provider == "aws") {
                customArgs = customArgs + " --sishDomain \"sish.osu.tiny.work\""
              }
              if (platform.os) {
                customArgs = customArgs + " --platformName \"${platform.os}\""
              }

              generateNPMVersionRouteFile(content: args.routeContent, filePath: args.routeFilePath)
              updateDependenciesWithTag(npmTag: args.npmTag)
              bedrockTests(
                name: name,
                browser: platform.browser,
                testDirs: [ "tinymce-angular-component/src/test/ts" ],
                bucket: currBucket,
                buckets: buckets,
                custom: customArgs
              )
            }
          }
        }
      } else {
        // Headless code in case is needed
        def name = "headless-${platform.browser}${suffix}"
        processes[name] = {
          stage("${name}") {
            generateNPMVersionRouteFile(content: args.routeContent, filePath: args.routeFilePath)
            updateDependenciesWithTag(npmTag: args.npmTag)
            bedrockTests(
              name: name,
              browser: platform.browser,
              testDirs: [ "tinymce-angular-component/src/test/ts" ],
              bucket: currBucket,
              buckets: buckets,
              custom: additionalArgs + " --useSelenium"
            )
          }
        }
      }
    }
  }

  parallel processes
}

def notify(Map slackArgs) {
  // In shared libraries, the `call` method is not in the pipeline CPS context. We need to call the `steps` object to safely call jenkins steps
  steps.retry(3) {
    return steps.slackSend([ username: 'TinyMCE Integration Smoke Test', failOnError: true ] + slackArgs)
  }
}


timestamps {
  tinyPods.node() {
    stage('deps') {
      yarnInstall()
    }

    stage('build') {
      sh 'yarn build'
    }

    stage('tests') {
      String npmTag = params.NPM_TAG ?: 'latest'
      // @angular/core's version is the one baked into the angular app
      String nextVersion = sh(script: "npm view @angular/core@${npmTag} version", returnStdout: true).trim()
      echo "The upcoming Angular version: ${nextVersion}"

      def customRouteContent = readJSON text: """
        [{
          "request": {
            "method": "get",
            "path": "/custom/integration/info"
          },
          "response": {
            "status": 200,
            "json": {
              "version": "${nextVersion} + smoke-test"
            }
          }
        }]
      """

      try {
        runSmokeTests(npmTag: npmTag, routeContent: customRouteContent, routeFilePath: "${WORKSPACE}/version.json")
      } catch (Exception e) {
        echo "Exception was caught: ${e}"
        currentBuild.result = 'FAILURE'
      } finally {
        if (currentBuild.result != 'SUCCESS') {
          def color = ['UNSTABLE': 'warning', 'FAILURE': 'danger']
          def message = currentBuild.result == 'UNSTABLE' ? 'Tests have failed' : 'Build has failed'
          notify(
            channel: '#tiny-integrations-dev',
            color: color.get(currentBuild.result, '#808080'),
            message: "Build ${env.JOB_NAME} #${env.BUILD_NUMBER} failed: ${message} (<${env.BUILD_URL}|Open>)"
          )
        }
      }
    }
  }
}
